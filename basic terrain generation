using UnityEngine;
using System.Collections;


/**
   This code generates ground sections infinitely:
     - Any ground/ceiling assets must be given a numerical name eg: 6, and that must be unique.
     - All ground (and ceiling) objects must be tagged "Ground" in order to avoid an error and they must be a prefab stored in the Prefab folder under a Resources folder
     - It may be neccesary to edit the right edge of the ground object to avoid rigidbody collisions between ground objects
     - All ground objects must have a rigidbody applied
     - Note the time between batch spawns can effect how the change ground timer works
     - All of the above is a bit of a pain, but it makes it more efficent

        THIS CODE CURRENTLY WRITTEN FOR UNITY3D :)))


    **/
public class gameHandling : MonoBehaviour
{
    GameObject ground;  // GameObject that stores the ground prefab
    GameObject groundSec; // Stores the most recently spawned section of ground, neccessary to manipulate each section
    float grTime = 10.1F;  // Timer that counts to when a new batch of ground sections should be spawned (every 10 seconds)
    float runTime = 0.0F; //Stores a running time that resets each time the ground section changes
    int i = 0; //loop control variable
    int z = 0; //stores current a index for groundChangeTime array
    int currentGroundSecID; //Stores the current ground object ID 
    float length; //Stores length of current ground section
    public int groundChangeTimer; //Time until ground object should change
    float y = 0F; //Stores the coordinate for where new ground objects should be instantiated  
    public int groundID1; //Stores a ground object ID to be used
    public int groundID2;
    public int groundID3;
    public int[,] groundChangeTime1 = new int[3,3]; //Stores the object ID for each change cycle, an array allows this to be expanded to a user defined number of different objectId's

    void Start()
    {
        string test = "Prefabs/groundSections/" + currentGroundSecID;
        Debug.Log(test);

        ground = (GameObject)Resources.Load("Prefabs/0", typeof(GameObject)) as GameObject; //set to default ground object
        length = ground.GetComponent<Renderer>().bounds.size.x;
        Debug.Log(ground);
        currentGroundSecID = z;
        groundChangeTime1[0, 1] = groundID1;
        groundChangeTime1[1, 1] = groundID2;
        groundChangeTime1[2, 1] = groundID3;

    }
    // Update is called once per frame
    void Update()
    {
        if(runTime > groundChangeTimer)
        {
            ground = SetGroundSection();
            length = ground.GetComponent<Renderer>().bounds.size.x;
            runTime = 0;
        }
        runTime = runTime + Time.deltaTime;
        if(grTime > 10.0) 
        {
            while(i < 2)  // Spawns 3 sections
            {
                //The position that each section is spawned at depends on the last instances' spawn position.
                if (groundSec != null) //When first run, groundSec will be null, if so this sets it to the default starting pos                      
                {
                    y = groundSec.transform.position.x+length;
                }     
                groundSec = (GameObject)Instantiate(ground, new Vector3(y, -8, 0), Quaternion.identity);  //groundSec is an instance of ground gameobject 
                groundSec.GetComponent<Rigidbody>().velocity = -9 * transform.localScale.x * groundSec.transform.right; //Applies velocity to each ground section
                i++;
            }
            grTime = 0.0F; //Resets timer to 0
            i = 0;
        }
        grTime = grTime + Time.deltaTime; //increments timer 

    }

   GameObject SetGroundSection()
    {
            z++;
            if (z == 3) //Loops back round to object 0
            {
                z = 0;
            }

            currentGroundSecID = groundChangeTime1[z, 1];
            ground = (GameObject)Resources.Load("Prefabs/" + currentGroundSecID, typeof(GameObject)) as GameObject;
            
        return ground;
    }

    
}
